\documentclass[a4paper,11pt]{article}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[french]{babel}
\usepackage{graphicx}

\title{Rapport Projet Conception Objet}
\author{Elouan Boiteux \\ Aymeric Mariaux \\Killian Mathias}
\date{\today}


\begin{document}

\maketitle
\newpage
\tableofcontents
\newpage

\section{Introduction}

Ce projet consiste en la modélisation d'un jeu : DorfJavatik. Ce dernier est inspiré d'un jeu existant : DorfRomantik. Ce jeu se joue à un seul joueur et consiste en un plateau de 25 cases dans lequel on peut placer des tuiles. Le joueur peut tourner et placer une tuile à chaque tour sur une des cases libres du plateau. Chaque tuile possède 4 zones : Nord, Sud, Est et Ouest. Chaque zone peut être un biome parmi les suivants : Rivière et lac, forêt, champ, village et montagne. L'objectif est de maximiser le score en faisant correspondre les biomes des tuiles adjacentes (par exemple, connecter une forêt à une autre forêt). A noter qu'à chaque tour, la tuile tirée est générée aléatoirement.
\newpage
\section{Diagrammes UML}

La première étape dans le développement d'un jeu est d'abord d'analyser et d'établir le cahier des charges. Pour ce faire nous utiliserons différent diagrammes UML, en commençant par le diagramme de classe.
\subsection{Diagramme de classe}

\begin{figure}[h!]
    \centering
    \includegraphics[width=0.8\linewidth]{assets/diagrammeClasse.png}
    \caption{Diagramme de classe}
    \label{diagrammeClasse}
\end{figure}

\subsubsection{Architecture MVC}
L'objectif de ce diagramme de classe est de mettre en évidence les différentes composantes de notre jeu. Dans un premier temps, nous avons décidé de suivre l'architecture MVC (Model View Controller) car il est explicité dans le sujet que l'affichage devait être en temps réel. Or, si l'affichage est explicitement cité alors nous avons pensé que suivre cette architecture en utilisant les Views serait pertinent.\\
Dans notre diagramme, la classe Vue jouera le rôle de View, la classe Partie jouera le rôle de Controller car c'est avant tout elle qui va gérer le comportement de notre jeu et enfin le reste jouera le rôle de Model car ce sont des structures de données qui seront utiles au bon fonctionnement de notre jeu sans gérer la logique derrière.\\

\subsubsection{Model}
Dans un diagramme de classe de classe, le choix des structures est essentiel au bon fonctionnement du produit final.\\
Dans un premier temps, pour notre tuile, nous avons trouvé pertinent de stocker les données dans différentes structures : Tuile, Zone, Biome et Couleur. Etant donné que la tuile possède 4 zones on a établi un lien 1 -> 4 de la tuile à la zone. Chaque zone possède un type parmi l'énumération Type Zone (Nord, Sud, Est et Ouest) ainsi qu'un biome associé. Un biome est soit : Rivière, Montagne, Village, Forêt et Champ. Pour ce qui est des couleurs des biomes, ça sera la vue qui gérera l'affichage de ces dernières.\\
Puis il faut aussi modéliser le plateau de jeu, qui peut être composé de 0 (au début de la partie) à 25 tuiles (à la fin de la partie).

\subsection{Diagramme d'objet}
\begin{figure}[h!]
    \centering
    \includegraphics[width=0.8\linewidth]{assets/diagrammeObjet.png}
    \caption{Diagramme d'objet}
    \label{diagrammeObjet}
\end{figure}

L'objectif du diagramme d'objet est de modéliser un exemple concret de notre jeu. Nous avons choisi de montrer le comportement de notre jeu en montrant le comportement d'une partie avec 2 tuiles sur le plateau. Elle-même composé de 4 Zone chacune.\\
Chaque Zone possède un biome, d'une couleur et d'un nom.\\

Dans notre exemple il y a 5 Biomes :
\begin{itemize}
    \item Rivière : Bleu
    \item Montagne : Gris
    \item Village : Jaune
    \item Forêt : Vert
    \item Champ : Jaune
\end{itemize}
Les deux tuiles sont composé de differents biomes et sont placées de manière à ce que les biomes soient connectés. Ce qui signifie que le nord de la première tuile est connecté au sud de la seconde tuile, cela genere donc un score de 1 dans la vue.\\


\subsection{Diagramme de séquence}
\begin{figure}[h!]
    \centering
    \includegraphics[width=\linewidth]{assets/diagrammeSequence.png}
    \caption{Diagramme de séquence}
    \label{diagrammeSequence}
\end{figure}
L'objectif du diagramme de séquence est de modéliser le comportent et les interactions que l'on souhaite entre les différents acteurs. Nous avons choisi comme acteurs le joueur, la vue, une tuile, la partie, l'usine de tuiles et le plateau de jeu.\\
Le rôle du joueur dans ce diagramme est de montrer ses interactions avec la vue car c'est bel et bien lui qui va effectuer les choix de jeu.\\
La vue va traiter les actions du joueur pour ensuite en faire une action concrète via la partie (le controller dans notre cas) ou la tuile, dans le cas où on souhaite la tourner.\\
En fonction du choix du joueur, la partie va effectuer différentes actions, comme lancer la partie, jouer une tuile et la placer sur le plateau.\\
En fonction de ces actions, la partie va faire appel à des classes telles que l'usine de tuiles pour générer une nouvelle tuile aléatoire, le plateau pour mettre à jour ce dernier.\\
Le plateau, comme montré dans le diagramme de classe est un élément Observable, et va donc être observé, ici par la vue. Cela signifie donc que si le plateau change alors la vue sera notifiée et affichera les changements en conséquence.\\

\subsection{Diagramme de cas d'utilisation}
\begin{figure}[h!]
    \centering
    \includegraphics[width=0.8\linewidth]{assets/diagrammeCasUtilisation.png}
    \caption{Diagramme de cas d'utilisation}
    \label{diagrammeCasUtilisation}
\end{figure}
L'objectif du diagramme de cas d'utilisation est de montrer les différents cas d'utilisation de notre jeu. Nous avons donc modélisé les différentes actions que le joueur peut effectuer lors de la partie.\\
Le joueur est l'acteur principal et peut interagir avec le système \verb|Jeu| via plusieurs fonctionnalités :\\
\begin{itemize}
    \item \textbf{Lancer la partie} : Initialise le plateau de jeu et la pioche de tuile.
    \item \textbf{Jouer un tour} : Permet d'obtenir la tuile suivante à placer.
    \item \textbf{Placer la tuile} : Permet de placer une tuile sur le plateau. (\verb+include+ de jouer un tour)
    \item \textbf{Tourner la tuile} : Change l'orientation de la tuile actuelle pour optimiser les connexions de biomes. (\verb+extend+ de jouer un tour)
    \item \textbf{Consulter le score} : Permet de voir le score actuel.
\end{itemize}

\subsection{Diagramme d'état-transition}
\begin{figure}[h!]
    \centering
    \includegraphics[width=\linewidth]{assets/diagrammeEtatTransition.jpeg}
    \caption{Diagramme d'état-transition}
    \label{diagrammeEtatTransition}
\end{figure}
L'objectif du diagramme d'état-transition est de montrer les différents états que peut prendre notre jeu au fur et a mesure du déroulement de la partie. Nous avons donc modéliser les differentes étapes de la partie de l'initialisation à la fin de la partie.\\
Les états sont les suivants :\\
\begin{itemize}
    \item \textbf{Initialisation} : L'état composite initial de la partie, où le joueur peut lancer la partie.
    \item \textbf{PlateauCréer} : L'état après que le plateau ai été créé.
    \item \textbf{TuileCréer} : L'état après que la tuile ai été créée.
    \item \textbf{Tour} : L'état composite où le joueur peut jouer un tour.
    \item \textbf{Attente Action} : L'état où le joueur peut placer une tuile, la tourner ou consulter le score.
    \item \textbf{Mise à jour} : L'état composite où la vue est mise a jour après avoir placer une tuile pour que le joueur puisse consulter le score.
    \item \textbf{Fin de partie} : L'état final de la partie, où le joueur peut consulter le score.
\end{itemize}

\newpage
\section{Patrons de conception}
Pour modéliser notre jeu DorfJavatik, nous avons utilisé trois patrons de conception différents : l'Observateur, la Factory et le Singleton. \\

\subsection{Patron Observateur}
Nous avons choisi de mettre en place le patron de conception Observateur pour que la Vue affiche en temps réel les données telles que le plateau ou le score du joueur. Pour ce faire, nous avons désigné la partie comme héritant de la classe Observable et la classe Vue héritant de Observer. Cela signifie qu'à chaque fois que la partie notifie la vue d'un changement alors la vue est mise à jour.

\subsection{Patron Factory}
Nous avons choisi d'implémenter le patron de conception Factory, car nous voulions qu'à chaque tour une tuile soit générée aléatoirement. Le but était donc de déléguer la tache de création aléatoire de ces tuiles à une entité différente de partie. Le patron de conception Factory correspondait parfaitement à notre besoin car il délègue la création d'un élément d'une classe à une usine (factory). Ici notre usine est la classe Tuile Factory qui possède une méthode créerTuile() et qui crée une tuile aléatoire.

\subsection{Patron Singleton}
Enfin, nous avons décidé d'utiliser le patron de conception Singleton car nous voulions que la partie soit unique. En effet, étant donné que ce n'est pas un jeu en ligne et que c'est un jeu à un seul joueur, il serait inutile de créer plusieurs instances du jeu. Nous avons donc utilisé ce patron dans le but de limiter notre partie à être unique.

\section{Conclusion}
Votre conclusion ici.

\end{document}
